//******************************************************************************
//
//
//      shot
//
//
//******************************************************************************

//------< インクルード >--------------------------------------------------------
#include "all.h"

//------< 変数 >----------------------------------------------------------------
int     shot_state;
Sprite* sprShot;
#if 9
//******************************************************************************
// TODO:09 弾の配列を用意
//------------------------------------------------------------------------------
/*
課題）
    OBJ2D型で要素数SHOT_MAXの配列shotを宣言します。
*/
//******************************************************************************
#endif
//TODO_09
OBJ2D shot[SHOT_MAX];

//--------------------------------------
//  弾の初期設定
//--------------------------------------
void shot_init()
{
#if 5
//******************************************************************************
// TODO:05 弾の初期設定
//------------------------------------------------------------------------------
/*
課題）
    shot_stateに0を代入しておきます。

解説）
    このソースコード自体が弾のマネージャのような働きをします。初期設定としては、
    shot_stateに0を代入するだけで良いのです。
*/
//******************************************************************************
#endif
    //TODO_05
    shot_state = 0;
}

//--------------------------------------
//  弾の終了処理
//--------------------------------------
void shot_deinit()
{
#if 6
//******************************************************************************
// TODO:06 弾の終了処理
//------------------------------------------------------------------------------
/*
課題）
    sprShotを破棄します。
*/
//******************************************************************************
#endif
    //TODO_06
    safe_delete(sprShot);
}

//--------------------------------------
//  弾の更新処理
//--------------------------------------
void shot_update()
{
    switch (shot_state)
    {
    case 0:
        //////// 初期設定 ////////

#if 7
//******************************************************************************
// TODO:07 弾の画像を読み込む
//------------------------------------------------------------------------------
/*
課題）
    sprShotにshot.pngを読み込みましょう。
*/
//******************************************************************************
#endif
        //TODO_07 
        sprShot = sprite_load(L"./Data/Images/shot.png");

        ++shot_state;
        /*fallthrough*/

    case 1:
        //////// パラメータの設定 ////////

#if 10
//******************************************************************************
// TODO:10 弾をクリア
//------------------------------------------------------------------------------
/*
課題）
    弾の配列を全て0でクリアします。
*/
//******************************************************************************
#endif
        //TODO_10
        for(int i=0;i<SHOT_MAX;++i)
        { 
            shot[i] = {}; 
            shot[i].radius = 20;
        }

        ++shot_state;
        /*fallthrough*/

    case 2:
        //////// 通常時 ////////

#if 21
//******************************************************************************
// TODO:21 範囲外チェック
//------------------------------------------------------------------------------
/*
課題）
    ここは弾の更新処理の通常時です。
    設問16で作成した下記のfor文の中で、各弾が行動を終えた後の箇所でエリアチェック
    を行いましょう。設問20で作成したareaCheck関数を呼び、弾が画面を含むエリア内に
    いなければ、弾の存在を消しましょう。
*/
//******************************************************************************
#endif
#if 16
//******************************************************************************
// TODO:16 弾の動作
//------------------------------------------------------------------------------
/*
課題）
    弾の通常時の動作を実装します。
    設問14で作成したのと同じ形のfor文を使います。

手順）
    for文でループ（設問14で作成したのと全く同じ）
        もし弾のmoveAlgがNULLであれば
            continue
        もし弾のエリアがプレイヤーのエリアと異なれば
            弾のmoveAlgにNULLを設定
            continue
        弾のmoveAlgから動作関数を呼び出す（引数は弾のアドレス）
*/
//******************************************************************************
#endif
        //TODO_16

  
        for (OBJ2D* s = SHOT_BEGIN; s != SHOT_END; ++s)
        {
            if (s->moveAlg == NULL) continue;


            if (s->area != player.area)
            {
                s->moveAlg = NULL;
                continue;
            }

            s->moveAlg(s);

            if (areaCheck(s) == false)
            {
                s->moveAlg = NULL;
            }
        }



        break;
    }
}

//--------------------------------------
//  弾の描画処理
//--------------------------------------
void shot_render()
{
#if 14
//******************************************************************************
// TODO:14 ポインタを使ったfor文
//------------------------------------------------------------------------------
/*
課題）
    ポインタを有効に使ってfor文のループを記述しましょう。
    設問13番で定義した定数を使用していきます。

    for文は下記のような形です。
    for (初期化式; 継続条件式; 再初期化式)
    {
        文;
    }

手順）
    まず、設問11で記述したforの行だけコメントアウトします。
    
    初期化式    OBJ2D* sにSHOT_BEGINを代入します。
    継続条件式  sがSHOT_ENDと等しくなければ継続します。
    再初期化式  sをインクリメントします。

    文          設問11で記述したshot[i]をsに置き換えましょう。
*/
//******************************************************************************
#endif
#if 11
//******************************************************************************
// TODO:11 弾の描画
//------------------------------------------------------------------------------
/*
課題）
    存在している弾を描画しましょう。
    
手順）
    for文でshot[0]からshot[SHOT_MAX-1]までをループ（添え字はint iとする）
        shot[i].moveAlgがNULLであればcontinue;
        sprite_render関数でshot[i]を描画

    ※sprite_renderの引数としては&shot[i]だけを入れておきます（設問12番で実装）
*/
//******************************************************************************
#endif
    //TODO_11 
    /*for (int i=0;i<SHOT_MAX;i++)*/

    for(OBJ2D* s=SHOT_BEGIN;s!=SHOT_END;++s)
    {
        if (s->moveAlg == NULL) continue; 
        
        sprite_render(s);

        primitive::circle(
            s->pos,
            s->radius, { 1, 1 },
            ToRadian(0), { 1, 0, 0, 0.2f }
        );

    }
  
}

/*********************************************************************************

    弾の移動関数

*********************************************************************************/

//--------------------------------------
//  ショット0（直進する弾）
//--------------------------------------
#if 15
//******************************************************************************
// TODO:15 弾の移動関数0
//------------------------------------------------------------------------------
/*
課題）
    弾0の移動関数を作成します。
    弾0はあらかじめ設定されたobj->angleの方角に向かって直進します。

    戻り値     void
    関数名     moveShot0
    引数       OBJ2D* obj

手順）
    1.  obj->actで分岐させる（switch文を使う）
        case 0      初期設定        break文無し
        case 1      通常時          break文有り

    2.  [初期設定]
        objの各メンバ変数に下記の値を設定します。

        spr         sprShot
        scale       { 2, 2 }
        texPos      { 0, 0 }
        texSize     { 8, 8 }
        pivot       { 4, 4 }
        color       { 1, 1, 1, 1 }

        speed       obj->angleの方向に長さ8となる値を設定します。

    3.  [通常時]
        位置に速度を足します。

補足）
    obj->angleにはあらかじめ値を設定しておく必要があります。
*/
//******************************************************************************
#endif
//TODO_15
void moveShot0(OBJ2D* obj)
{

    switch (obj->act)
    {
    case 0:
        
        obj->spr = sprShot;
        obj->scale = { 2,2 };
        obj->texPos = { 0,0 };
        obj->texSize = { 8,8 };
        obj->pivot = { 4,4 };
        obj->color = { 1,1,1,1 };
        obj->speed = {
            8*sinf(obj->angle), 
            8*-cosf(obj->angle)
        };

        obj->act++;

    case 1:
        obj->pos += obj->speed;

        break;
    }
}

void moveShot0_2(OBJ2D* obj)
{

    switch (obj->act)
    {
    case 0:

        obj->spr = sprShot;
        obj->scale = { 2,2 };
        obj->texPos = { 0,0 };
        obj->texSize = { 8,8 };
        obj->pivot = { 4,4 };
        obj->color = { 1,1,1,1 };
        obj->speed = {
            8 * sinf(obj->angle+ToRadian(90)),
            8 * -cosf(obj->angle + ToRadian(90))
        };

        obj->act++;

    case 1:
        obj->pos += obj->speed;

        break;
    }
}

void moveShot0_3(OBJ2D* obj)
{

    switch (obj->act)
    {
    case 0:

        obj->spr = sprShot;
        obj->scale = { 2,2 };
        obj->texPos = { 0,0 };
        obj->texSize = { 8,8 };
        obj->pivot = { 4,4 };
        obj->color = { 1,1,1,1 };
        obj->speed = {
            8 * sinf(obj->angle + ToRadian(180)),
            8 * -cosf(obj->angle + ToRadian(180))
        };

        obj->act++;

    case 1:
        obj->pos += obj->speed;

        break;
    }
}
void moveShot0_4(OBJ2D* obj)
{

    switch (obj->act)
    {
    case 0:

        obj->spr = sprShot;
        obj->scale = { 2,2 };
        obj->texPos = { 0,0 };
        obj->texSize = { 8,8 };
        obj->pivot = { 4,4 };
        obj->color = { 1,1,1,1 };
        obj->speed = {
            8 * sinf(obj->angle + ToRadian(270)),
            8 * -cosf(obj->angle + ToRadian(270))
        };

        obj->act++;

    case 1:
        obj->pos += obj->speed;

        break;
    }
}
//--------------------------------------
//  ショット1（プレイヤーに向かう方向弾）
//--------------------------------------
#if 22
//******************************************************************************
// TODO:22 弾の移動関数1
//------------------------------------------------------------------------------
/*
課題）
    弾1の移動関数を作成します。
    弾1は発射された位置から、プレイヤーに向かって真っすぐ飛んでいきます。

    戻り値     void
    関数名     moveShot1
    引数       OBJ2D* obj

手順）
    1.  obj->actで分岐させる（switch文を使う）
        case 0      初期設定        break文無し
        case 1      通常時          break文有り

    2.  [初期設定]
        objの各メンバ変数に下記の値を設定します。

        spr         sprShot
        scale       { 2, 2 }
        texPos      { 0, 0 }
        texSize     { 8, 8 }
        pivot       { 4, 4 }
        color       { 1, 1, 1, 1 }

        speed       obj->posからプレイヤーに向かって速度4で進む値を設定します。
                    [プリント参照]

    3.  [通常時]
        位置に速度を足します。
*/
//******************************************************************************
#endif
//TODO_22
void moveShot1(OBJ2D* obj)
{

    switch (obj->act)
    {
    case 0:
    {
        float dx = player.pos.x- obj->pos.x;
        float dy = player.pos.y- obj->pos.y;
        float dis = sqrtf(dx * dx + dy * dy);

        obj->spr = sprShot;
        obj->scale = { 2,2 };
        obj->texPos = { 0,0 };
        obj->texSize = { 8,8 };
        obj->pivot = { 4,4 };
        obj->color = { 1,1,1,1 };
        obj->speed = { dx / dis * 4,dy / dis * 4 };
        obj->act++;
    }
        
    case 1:
        obj->pos += obj->speed;
        break;
    }
}


//--------------------------------------
//  ショット2（最初広がって → 方向弾）
//--------------------------------------
#if 25
//******************************************************************************
// TODO:25 弾の移動関数2
//------------------------------------------------------------------------------
/*
課題）
    弾2の移動関数を作成します。
    弾2は、あらかじめ設定されたangleの方向に一定時間飛んでいき、一定時間静止し、
    その後プレイヤーへと方向を変えて直進する弾です。

    戻り値     void
    関数名     moveShot2
    引数       OBJ2D* obj

手順）
    1.  obj->actで分岐させる（switch文を使う）
        case 0      初期設定                  break文無し
        case 1      広がる                    break文有り
        case 2      自機へと向かう速度を設定  break文無し
        case 3      待機                      break文有り
        case 4      通常時                    break文有り

    2.  [初期設定]
        objの各メンバ変数に下記の値を設定します。

        spr         sprShot
        scale       { 2, 2 }
        texPos      { 0, 0 }
        texSize     { 8, 8 }
        pivot       { 4, 4 }
        color       { 1, 1, 1, 1 }
        speed       angleの方向へ長さ6
        timer       30

    3.  [広がる]
        timerを1減らす
        もしtimerが0以下になっていたら
            actをインクリメントする
        posにspeedを足す

    4.  [自機へと向かう速度を設定]
        speedに、その時点のposからプレイヤーの中心へと向かう長さ12のベクトルを設定
        timerに30を設定

    5.  [待機]
        timerを1減らす
        もしtimerが0以下になっていたら
            actをインクリメントする

    6.  [通常時]
        位置に速度を足す
*/
//******************************************************************************
#endif
//TODO_25

void moveShot2(OBJ2D* obj)
{
    switch (obj->act)
    {

    case 0://初期設定
 
        obj->spr = sprShot;
        obj->scale = { 2,2 };
        obj->texPos = { 0,0 };
        obj->texSize = { 8,8 };
        obj->pivot = { 4,4 };
        obj->color = { 1,1,1,1 };
        obj->speed = { 6 * sinf(obj->angle),6 * -cosf(obj->angle) };
        obj->timer = 30;
        obj->act++;
    
    case 1://広がる
        --obj->timer;
        if (obj->timer <= 0)
        {
            ++obj->act;
        }
        obj->pos += obj->speed;

        break;
    case 2://自機へ向かう速度を設定
    {
        float dx = player.pos.x - obj->pos.x;
        float dy = player.pos.y - obj->pos.y;
        float dis = sqrtf(dx * dx + dy * dy);

        obj->speed = { 12 * dx / dis,12 * dy / dis };
        obj->timer = 30;
        obj->act++;
    }

    case 3://待機
        --obj->timer;
        if (obj->timer <= 0) obj->act++;
        
        break;
    case 4://通常時
        obj->pos += obj->speed;
        
        break;
    }
    }
